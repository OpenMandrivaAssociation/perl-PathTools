--- PathTools-3.33/Cwd.pm.bero	2012-07-20 20:08:16.656104352 +0200
+++ PathTools-3.33/Cwd.pm	2012-07-20 20:11:06.755677596 +0200
@@ -202,28 +202,12 @@ if ($^O eq 'os2') {
     return 1;
 }
 
-# Need to look up the feature settings on VMS.  The preferred way is to use the
-# VMS::Feature module, but that may not be available to dual life modules.
-
-my $use_vms_feature;
-BEGIN {
-    if ($^O eq 'VMS') {
-        if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
-            $use_vms_feature = 1;
-        }
-    }
-}
-
 # Need to look up the UNIX report mode.  This may become a dynamic mode
 # in the future.
 sub _vms_unix_rpt {
     my $unix_rpt;
-    if ($use_vms_feature) {
-        $unix_rpt = VMS::Feature::current("filename_unix_report");
-    } else {
-        my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
-        $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
-    }
+    my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
+    $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
     return $unix_rpt;
 }
 
@@ -231,12 +215,8 @@ sub _vms_unix_rpt {
 # mode in the future.
 sub _vms_efs {
     my $efs;
-    if ($use_vms_feature) {
-        $efs = VMS::Feature::current("efs_charset");
-    } else {
-        my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
-        $efs = $env_efs =~ /^[ET1]/i; 
-    }
+    my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
+    $efs = $env_efs =~ /^[ET1]/i; 
     return $efs;
 }
 
@@ -256,80 +236,6 @@ eval {
 # Must be after the DynaLoader stuff:
 $VERSION = eval $VERSION;
 
-# Big nasty table of function aliases
-my %METHOD_MAP =
-  (
-   VMS =>
-   {
-    cwd			=> '_vms_cwd',
-    getcwd		=> '_vms_cwd',
-    fastcwd		=> '_vms_cwd',
-    fastgetcwd		=> '_vms_cwd',
-    abs_path		=> '_vms_abs_path',
-    fast_abs_path	=> '_vms_abs_path',
-   },
-
-   MSWin32 =>
-   {
-    # We assume that &_NT_cwd is defined as an XSUB or in the core.
-    cwd			=> '_NT_cwd',
-    getcwd		=> '_NT_cwd',
-    fastcwd		=> '_NT_cwd',
-    fastgetcwd		=> '_NT_cwd',
-    abs_path		=> 'fast_abs_path',
-    realpath		=> 'fast_abs_path',
-   },
-
-   dos => 
-   {
-    cwd			=> '_dos_cwd',
-    getcwd		=> '_dos_cwd',
-    fastgetcwd		=> '_dos_cwd',
-    fastcwd		=> '_dos_cwd',
-    abs_path		=> 'fast_abs_path',
-   },
-
-   # QNX4.  QNX6 has a $os of 'nto'.
-   qnx =>
-   {
-    cwd			=> '_qnx_cwd',
-    getcwd		=> '_qnx_cwd',
-    fastgetcwd		=> '_qnx_cwd',
-    fastcwd		=> '_qnx_cwd',
-    abs_path		=> '_qnx_abs_path',
-    fast_abs_path	=> '_qnx_abs_path',
-   },
-
-   cygwin =>
-   {
-    getcwd		=> 'cwd',
-    fastgetcwd		=> 'cwd',
-    fastcwd		=> 'cwd',
-    abs_path		=> 'fast_abs_path',
-    realpath		=> 'fast_abs_path',
-   },
-
-   epoc =>
-   {
-    cwd			=> '_epoc_cwd',
-    getcwd	        => '_epoc_cwd',
-    fastgetcwd		=> '_epoc_cwd',
-    fastcwd		=> '_epoc_cwd',
-    abs_path		=> 'fast_abs_path',
-   },
-
-   MacOS =>
-   {
-    getcwd		=> 'cwd',
-    fastgetcwd		=> 'cwd',
-    fastcwd		=> 'cwd',
-    abs_path		=> 'fast_abs_path',
-   },
-  );
-
-$METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
-
-
 # Find the pwd command in the expected locations.  We assume these
 # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
 # so everything works under taint mode.
@@ -373,7 +279,7 @@ sub _backtick_pwd {
 # Since some ports may predefine cwd internally (e.g., NT)
 # we take care not to override an existing definition for cwd().
 
-unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
+unless (defined &cwd) {
     # The pwd command is not available in some chroot(2)'ed environments
     my $sep = $Config::Config{path_sep} || ':';
     my $os = $^O;  # Protect $^O from tainting
@@ -509,17 +415,6 @@ sub chdir {
 
     return 0 unless CORE::chdir $newdir;
 
-    if ($^O eq 'VMS') {
-	return $ENV{'PWD'} = $ENV{'DEFAULT'}
-    }
-    elsif ($^O eq 'MacOS') {
-	return $ENV{'PWD'} = cwd();
-    }
-    elsif ($^O eq 'MSWin32') {
-	$ENV{'PWD'} = $newpwd;
-	return 1;
-    }
-
     if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
 	$ENV{'PWD'} = cwd();
     } elsif ($newdir =~ m#^/#s) {
@@ -671,148 +566,9 @@ sub fast_abs_path {
 
 # --- PORTING SECTION ---
 
-# VMS: $ENV{'DEFAULT'} points to default directory at all times
-# 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
-# Note: Use of Cwd::chdir() causes the logical name PWD to be defined
-#   in the process logical name table as the default device and directory
-#   seen by Perl. This may not be the same as the default device
-#   and directory seen by DCL after Perl exits, since the effects
-#   the CRTL chdir() function persist only until Perl exits.
-
-sub _vms_cwd {
-    return $ENV{'DEFAULT'};
-}
-
-sub _vms_abs_path {
-    return $ENV{'DEFAULT'} unless @_;
-    my $path = shift;
-
-    my $efs = _vms_efs;
-    my $unix_rpt = _vms_unix_rpt;
-
-    if (defined &VMS::Filespec::vmsrealpath) {
-        my $path_unix = 0;
-        my $path_vms = 0;
-
-        $path_unix = 1 if ($path =~ m#(?<=\^)/#);
-        $path_unix = 1 if ($path =~ /^\.\.?$/);
-        $path_vms = 1 if ($path =~ m#[\[<\]]#);
-        $path_vms = 1 if ($path =~ /^--?$/);
-
-        my $unix_mode = $path_unix;
-        if ($efs) {
-            # In case of a tie, the Unix report mode decides.
-            if ($path_vms == $path_unix) {
-                $unix_mode = $unix_rpt;
-            } else {
-                $unix_mode = 0 if $path_vms;
-            }
-        }
-
-        if ($unix_mode) {
-            # Unix format
-            return VMS::Filespec::unixrealpath($path);
-        }
-
-	# VMS format
-
-	my $new_path = VMS::Filespec::vmsrealpath($path);
-
-	# Perl expects directories to be in directory format
-	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
-	return $new_path;
-    }
-
-    # Fallback to older algorithm if correct ones are not
-    # available.
-
-    if (-l $path) {
-        my $link_target = readlink($path);
-        die "Can't resolve link $path: $!" unless defined $link_target;
-
-        return _vms_abs_path($link_target);
-    }
-
-    # may need to turn foo.dir into [.foo]
-    my $pathified = VMS::Filespec::pathify($path);
-    $path = $pathified if defined $pathified;
-	
-    return VMS::Filespec::rmsexpand($path);
-}
-
-sub _os2_cwd {
-    $ENV{'PWD'} = `cmd /c cd`;
-    chomp $ENV{'PWD'};
-    $ENV{'PWD'} =~ s:\\:/:g ;
-    return $ENV{'PWD'};
-}
-
-sub _win32_cwd {
-    if (eval 'defined &DynaLoader::boot_DynaLoader') {
-	$ENV{'PWD'} = Win32::GetCwd();
-    }
-    else { # miniperl
-	chomp($ENV{'PWD'} = `cd`);
-    }
-    $ENV{'PWD'} =~ s:\\:/:g ;
-    return $ENV{'PWD'};
-}
-
-*_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_os2_cwd;
-
-sub _dos_cwd {
-    if (!defined &Dos::GetCwd) {
-        $ENV{'PWD'} = `command /c cd`;
-        chomp $ENV{'PWD'};
-        $ENV{'PWD'} =~ s:\\:/:g ;
-    } else {
-        $ENV{'PWD'} = Dos::GetCwd();
-    }
-    return $ENV{'PWD'};
-}
-
-sub _qnx_cwd {
-	local $ENV{PATH} = '';
-	local $ENV{CDPATH} = '';
-	local $ENV{ENV} = '';
-    $ENV{'PWD'} = `/usr/bin/fullpath -t`;
-    chomp $ENV{'PWD'};
-    return $ENV{'PWD'};
-}
-
-sub _qnx_abs_path {
-	local $ENV{PATH} = '';
-	local $ENV{CDPATH} = '';
-	local $ENV{ENV} = '';
-    my $path = @_ ? shift : '.';
-    local *REALPATH;
-
-    defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
-      die "Can't open /usr/bin/fullpath: $!";
-    my $realpath = <REALPATH>;
-    close REALPATH;
-    chomp $realpath;
-    return $realpath;
-}
-
-sub _epoc_cwd {
-    $ENV{'PWD'} = EPOC::getcwd();
-    return $ENV{'PWD'};
-}
-
-
 # Now that all the base-level functions are set up, alias the
 # user-level functions to the right places
 
-if (exists $METHOD_MAP{$^O}) {
-  my $map = $METHOD_MAP{$^O};
-  foreach my $name (keys %$map) {
-    local $^W = 0;  # assignments trigger 'subroutine redefined' warning
-    no strict 'refs';
-    *{$name} = \&{$map->{$name}};
-  }
-}
-
 # In case the XS version doesn't load.
 *abs_path = \&_perl_abs_path unless defined &abs_path;
 *getcwd = \&_perl_getcwd unless defined &getcwd;
